name: Unified Build and Release Pipeline

on:
  push:
    branches: [ main, master, develop ]
    tags:
      - 'v*'
    paths-ignore:
      - 'README.md'
      - 'CHANGELOG.md'
      - 'docs/**'
      - '.gitignore'
  # Manual trigger with parameters
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (without v prefix)'
        required: false
        default: ''
      is_beta:
        description: 'Is this a beta version'
        required: false
        default: false
        type: boolean
  # GitHub Release created
  release:
    types: [created]

# Permissions applied to the entire workflow
permissions:
  contents: write
  packages: write

jobs:
  # Determine the version for the build
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      is_beta: ${{ steps.set-version.outputs.is_beta }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set Version
        id: set-version
        run: |
          # Determine version based on event type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            # Manually provided version
            VERSION="${{ github.event.inputs.version }}"
            IS_BETA="${{ github.event.inputs.is_beta }}"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Version from a tag
            VERSION=${GITHUB_REF#refs/tags/v}
            # Check if it's beta based on tag name
            if [[ "$VERSION" == *-beta* || "$VERSION" == *-alpha* || "$VERSION" == *-rc* ]]; then
              IS_BETA="true"
            else
              IS_BETA="false"
            fi
          else
            # Automatic determination as fallback
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"
            
            # Remove 'v' from beginning
            LATEST_VERSION=${LATEST_TAG#v}
            
            # Split version into parts: MAJOR.MINOR.PATCH
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            
            # Remove any suffix from PATCH (like -beta)
            PATCH=$(echo $PATCH | sed -E 's/([0-9]+).*/\1/')
            
            # Increment PATCH
            NEW_PATCH=$((PATCH + 1))
            
            # Determine if it's beta based on branch
            IS_BETA="false"
            if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              IS_BETA="true"
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}-beta"
            elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" ]]; then
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            else
              # For other cases
              VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi
          fi
          
          echo "Determined version: v${VERSION} (Beta: $IS_BETA)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "is_beta=${IS_BETA}" >> $GITHUB_OUTPUT

  # Run tests before build
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: version
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Unit Tests
        run: make test-unit
  
  # Build for multiple platforms
  build:
    name: Build
    needs: [test, version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform:
          - {goos: linux, goarch: amd64, suffix: ''}
          - {goos: linux, goarch: arm64, suffix: ''}
          - {goos: darwin, goarch: amd64, suffix: ''}
          - {goos: darwin, goarch: arm64, suffix: ''}
          - {goos: windows, goarch: amd64, suffix: '.exe'}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider
        env:
          GOOS: ${{ matrix.platform.goos }}
          GOARCH: ${{ matrix.platform.goarch }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building for $GOOS/$GOARCH - version v${VERSION}"
          
          # Directory structure compatible with Terraform
          # terraform-provider-jumpcloud_v${VERSION}_${OS}_${ARCH}/terraform-provider-jumpcloud_v${VERSION}
          PLUGIN_DIR=terraform-provider-jumpcloud_v${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          mkdir -p ${PLUGIN_DIR}
          
          # Compile for the platform with correct name
          go build -o ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Create ZIP for the binary with the structure expected by Terraform
          zip -j terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Add important information inside the ZIP
          echo "github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}" > ${PLUGIN_DIR}/registry-url.txt
          zip -r terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}
      
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-provider-jumpcloud_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          path: terraform-provider-jumpcloud_${{ needs.version.outputs.version }}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip
          if-no-files-found: error
          retention-days: 7

  # Prepare for publishing
  prepare-release:
    name: Prepare Release
    needs: [build, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
      
      - name: Generate Checksums
        run: |
          # Move all ZIPs to a single directory
          mkdir -p release
          find . -name "terraform-provider-jumpcloud_*.zip" -exec cp {} release/ \;
          
          # Generate checksums
          cd release
          sha256sum *.zip > SHA256SUMS
          cd ..
      
      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            release/*.zip
            release/SHA256SUMS
          if-no-files-found: error
          retention-days: 7

  # Create Tag if it doesn't exist
  create-tag:
    name: Create Tag
    needs: [prepare-release, version]
    # Runs only if it's a push to main, master or develop branches
    if: ${{ github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Create Tag if Not Exists
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if the tag already exists
          if ! git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Creating tag v${VERSION}"
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git tag -a "v${VERSION}" -m "Release v${VERSION}"
            git push origin "v${VERSION}"
            echo "Tag v${VERSION} created and pushed"
          else
            echo "Tag v${VERSION} already exists"
          fi

  # Publish to GitHub Container Registry (GHCR)
  publish-packages:
    name: Publish to GitHub Container Registry
    needs: [prepare-release, version, create-tag]
    # Runs only if it's a push to main, master, develop, or if a tag is created, or manual dispatch
    if: |
      success() && (
        github.event_name == 'workflow_dispatch' || 
        startsWith(github.ref, 'refs/tags/') || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64,darwin/amd64,darwin/arm64,windows/amd64
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Prepare Provider for GHCR
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          cd release
          echo "Preparing provider for publication in GHCR..."
          
          # Check directory contents
          ls -la
          
          # Create working directory
          mkdir -p terraform-provider
          cp *.zip terraform-provider/
          cp SHA256SUMS terraform-provider/
          
          # Create Dockerfile
          cat << EOF > terraform-provider/Dockerfile
          FROM --platform=\${BUILDPLATFORM} alpine:3.17
          
          ARG TARGETPLATFORM
          ARG BUILDPLATFORM
          
          LABEL org.opencontainers.image.source=https://github.com/${{ github.repository }}
          LABEL org.opencontainers.image.description="JumpCloud Terraform Provider v${VERSION} - Platform-specific build for \${TARGETPLATFORM}"
          LABEL org.opencontainers.image.licenses=MIT
          LABEL io.jumpcloud.terraform.platforms="linux_amd64,linux_arm64,darwin_amd64,darwin_arm64,windows_amd64"
          LABEL io.jumpcloud.terraform.version="${VERSION}"
          LABEL io.jumpcloud.terraform.targetplatform="\${TARGETPLATFORM}"
          
          WORKDIR /terraform-provider
          
          # Copy platform-specific binaries and checksums
          COPY *.zip /terraform-provider/
          COPY SHA256SUMS /terraform-provider/
          
          # Create platform identifier file
          RUN echo "\${TARGETPLATFORM}" > /terraform-provider/PLATFORM
          
          CMD ["sh", "-c", "echo 'This is a Terraform Provider container for platform: '\$(cat /terraform-provider/PLATFORM)"]
          EOF
          
          # Create README
          cat << EOF > terraform-provider/README.md
          # JumpCloud Terraform Provider
          
          This image contains the JumpCloud provider for Terraform v${VERSION}.
          
          ## Supported Platforms
          
          This provider supports the following platforms:
          
          - Linux (AMD64, ARM64)
          - macOS (AMD64, ARM64)
          - Windows (AMD64)
          
          Each platform has a dedicated container image tag, and Terraform will automatically select the appropriate binary for your system.
          
          ## How to use with Terraform
          
          Add the following configuration to your Terraform file:
          
          \`\`\`hcl
          terraform {
            required_providers {
              jumpcloud = {
                source  = "ghcr.io/${{ github.repository_owner }}/jumpcloud"
                version = "${VERSION}"
              }
            }
          }
          
          provider "jumpcloud" {
            api_key = "your_api_key"
          }
          \`\`\`
          
          ## Terraform configuration to use GHCR
          
          Add the following configuration to your \`~/.terraformrc\` file (Linux/Mac) or \`%APPDATA%\\terraform.rc\` (Windows):
          
          \`\`\`hcl
          provider_installation {
            network_mirror {
              url = "https://ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud"
              include = ["ghcr.io/${{ github.repository_owner }}/jumpcloud"]
            }
            direct {
              exclude = ["ghcr.io/${{ github.repository_owner }}/jumpcloud"]
            }
          }
          \`\`\`
          
          ## Available files
          
          Each platform-specific container includes:
          
          - Provider binaries for all platforms
          - SHA256SUMS checksum file
          - Platform identifier
          EOF
      
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./release/terraform-provider
          push: true
          platforms: linux/amd64,linux/arm64,darwin/amd64,darwin/arm64,windows/amd64
          tags: |
            ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${{ needs.version.outputs.version }}
            ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:latest
            ${{ needs.version.outputs.is_beta == 'true' && format('ghcr.io/{0}/terraform-provider-jumpcloud:beta', github.repository_owner) || '' }}
      
      - name: Create Documentation for GHCR Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
        run: |
          echo "Publication to GHCR completed successfully!"
          echo "Terraform Provider available at: ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${VERSION}"
          
          # Debug: List available Docker images
          echo "Available Docker images:"
          docker images
          
          # Output information about the published images
          echo "The following container images have been published:"
          echo "- ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${VERSION} (specific version)"
          echo "- ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:latest (latest stable)"
          
          if [[ "$IS_BETA" == "true" ]]; then
            echo "- ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:beta (latest beta version)"
            echo ""
            echo "This container image includes provider binaries for ALL supported platforms:"
            echo "- Linux AMD64 & ARM64"
            echo "- MacOS AMD64 & ARM64"
            echo "- Windows AMD64"
          fi

  # Create GitHub Release (for any version, marking as beta when appropriate)
  create-github-release:
    name: Create GitHub Release
    needs: [prepare-release, version, publish-packages]
    # Runs for tags, official releases, merges to main/master/develop and manual workflow
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'workflow_dispatch') ||
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: Release v${{ needs.version.outputs.version }}
          files: |
            release/*.zip
            release/SHA256SUMS
          draft: false
          prerelease: ${{ needs.version.outputs.is_beta == 'true' }}
          generate_release_notes: true
      
      - name: Update CHANGELOG
        if: ${{ needs.version.outputs.is_beta != 'true' }}
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Generate content for the changelog
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          echo "## v${VERSION} ($(date +%Y-%m-%d))" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          
          # Get logs since the last non-beta release
          LAST_STABLE_TAG=$(git tag -l --sort=-v:refname | grep -v -E '-(beta|alpha|rc|pr)' | head -n1)
          if [ -n "$LAST_STABLE_TAG" ]; then
            # Group commits by type (feat, fix, etc)
            echo "### Features" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^feat(\([^)]+\))?:' | sed 's/^feat\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Bug Fixes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^fix(\([^)]+\))?:' | sed 's/^fix\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Documentation" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^docs(\([^)]+\))?:' | sed 's/^docs\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Other Changes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -v -E '^(feat|fix|docs)(\([^)]+\))?:' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
          else
            echo "* Initial release" >> $TEMP_CHANGELOG
            echo "" >> $TEMP_CHANGELOG
          fi
          
          # Add the previous changelog
          if [ -f CHANGELOG.md ]; then
            tail -n +3 CHANGELOG.md >> $TEMP_CHANGELOG
          fi
          
          # Replace the changelog
          mv $TEMP_CHANGELOG CHANGELOG.md
          
          # Commit and push changes if there's something to commit
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to commit in CHANGELOG.md"
          else
            git commit -m "docs: update CHANGELOG for v${VERSION}"
            git push
          fi

  # Special build for the Terraform Registry (for all versions)
  registry-build:
    name: Registry Build
    # Runs for tags, official releases, and merges to main/master/develop
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    needs: [create-github-release, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider for Registry Protocols
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building provider version ${VERSION} for Terraform Registry"
          
          # Create directory for compiled binaries
          mkdir -p dist
          
          # Compile for supported platforms
          GOOS=linux GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}
          GOOS=darwin GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_amd64
          GOOS=darwin GOARCH=arm64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_arm64
          GOOS=windows GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_windows_amd64.exe
      
      - name: Prepare Provider Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Create directory for the package
          mkdir -p terraform-provider-jumpcloud_${VERSION}
          
          # Copy the compiled binaries
          cp dist/* terraform-provider-jumpcloud_${VERSION}/
          
          # Add necessary files
          cp LICENSE terraform-provider-jumpcloud_${VERSION}/
          cp README.md terraform-provider-jumpcloud_${VERSION}/
          cp CHANGELOG.md terraform-provider-jumpcloud_${VERSION}/
          
          # Package
          tar -czvf terraform-provider-jumpcloud_${VERSION}.tar.gz terraform-provider-jumpcloud_${VERSION}
      
      - name: Upload Provider Package
        uses: actions/upload-artifact@v4
        with:
          name: terraform-registry-package
          path: terraform-provider-jumpcloud_*.tar.gz
          if-no-files-found: error
          retention-days: 30
      
      - name: Registry Publishing Mockup
        run: |
          echo "This is a mockup step for publication to the Terraform Registry."
          echo "In a real environment, you would integrate with the Terraform Registry API or follow"
          echo "the appropriate process for publishing external providers." 