name: Unified Build and Release Pipeline

on:
  push:
    branches: [ main, master, develop ]
    tags:
      - 'v*'
    paths-ignore:
      - 'README.md'
      - 'CHANGELOG.md'
      - 'docs/**'
      - '.gitignore'
  # Acionamento manual com parâmetros
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (without v prefix)'
        required: false
        default: ''
      is_beta:
        description: 'Is this a beta version'
        required: false
        default: false
        type: boolean
  # Release criada no GitHub
  release:
    types: [created]

# Permissões aplicadas a todo o workflow
permissions:
  contents: write
  packages: write

jobs:
  # Determinar a versão para o build
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      is_beta: ${{ steps.set-version.outputs.is_beta }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set Version
        id: set-version
        run: |
          # Determinar versão baseado no tipo de evento
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            # Versão fornecida manualmente
            VERSION="${{ github.event.inputs.version }}"
            IS_BETA="${{ github.event.inputs.is_beta }}"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Versão de uma tag
            VERSION=${GITHUB_REF#refs/tags/v}
            # Verificar se é beta baseado no nome da tag
            if [[ "$VERSION" == *-beta* || "$VERSION" == *-alpha* || "$VERSION" == *-rc* ]]; then
              IS_BETA="true"
            else
              IS_BETA="false"
            fi
          else
            # Determinação automática como fallback
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"
            
            # Remover 'v' do início
            LATEST_VERSION=${LATEST_TAG#v}
            
            # Dividir versão em partes: MAJOR.MINOR.PATCH
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            
            # Remover qualquer sufixo do PATCH (como -beta)
            PATCH=$(echo $PATCH | sed -E 's/([0-9]+).*/\1/')
            
            # Incrementar PATCH
            NEW_PATCH=$((PATCH + 1))
            
            # Determinar se é beta baseado na branch
            IS_BETA="false"
            if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              IS_BETA="true"
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}-beta"
            elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" ]]; then
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            else
              # Para outros casos
              VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi
          fi
          
          echo "Determined version: v${VERSION} (Beta: $IS_BETA)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "is_beta=${IS_BETA}" >> $GITHUB_OUTPUT

  # Executar testes antes do build
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: version
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Unit Tests
        run: make test-unit
  
  # Build para várias plataformas
  build:
    name: Build
    needs: [test, version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform:
          - {goos: linux, goarch: amd64, suffix: ''}
          - {goos: linux, goarch: arm64, suffix: ''}
          - {goos: darwin, goarch: amd64, suffix: ''}
          - {goos: darwin, goarch: arm64, suffix: ''}
          - {goos: windows, goarch: amd64, suffix: '.exe'}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider
        env:
          GOOS: ${{ matrix.platform.goos }}
          GOARCH: ${{ matrix.platform.goarch }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building for $GOOS/$GOARCH - version v${VERSION}"
          
          # Estrutura de diretórios compatível com Terraform
          # terraform-provider-jumpcloud_v${VERSION}_${OS}_${ARCH}/terraform-provider-jumpcloud_v${VERSION}
          PLUGIN_DIR=terraform-provider-jumpcloud_v${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          mkdir -p ${PLUGIN_DIR}
          
          # Compilar para a plataforma com nome correto
          go build -o ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Criar ZIP para o binário com a estrutura esperada pelo Terraform
          zip -j terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Adicionar informações importantes dentro do ZIP
          echo "github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}" > ${PLUGIN_DIR}/registry-url.txt
          zip -r terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}
      
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-provider-jumpcloud_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          path: terraform-provider-jumpcloud_${{ needs.version.outputs.version }}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip
          if-no-files-found: error
          retention-days: 7

  # Preparar para publicação
  prepare-release:
    name: Prepare Release
    needs: [build, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
      
      - name: Generate Checksums
        run: |
          # Mover todos os ZIPs para um único diretório
          mkdir -p release
          find . -name "terraform-provider-jumpcloud_*.zip" -exec cp {} release/ \;
          
          # Gerar checksums
          cd release
          sha256sum *.zip > SHA256SUMS
          cd ..
      
      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            release/*.zip
            release/SHA256SUMS
          if-no-files-found: error
          retention-days: 7

  # Criar Tag se não existir
  create-tag:
    name: Create Tag
    needs: [prepare-release, version]
    # Executa apenas se for push para branches main, master ou develop
    if: ${{ github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Create Tag if Not Exists
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Verificar se a tag já existe
          if ! git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Creating tag v${VERSION}"
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git tag -a "v${VERSION}" -m "Release v${VERSION}"
            git push origin "v${VERSION}"
            echo "Tag v${VERSION} created and pushed"
          else
            echo "Tag v${VERSION} already exists"
          fi

  # Publicar no GitHub Packages
  publish-packages:
    name: Publish to GitHub Packages
    needs: [prepare-release, version, create-tag]
    # Executa apenas se for push para branches main, master, develop, ou se for criada uma tag, ou manual dispatch
    if: |
      success() && (
        github.event_name == 'workflow_dispatch' || 
        startsWith(github.ref, 'refs/tags/') || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Set up GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          
      - name: Publish to GitHub Packages
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          cd release
          echo "Publishing packages to GitHub Packages..."
          
          # Verificar conteúdo do diretório
          ls -la
          
          # Informações sobre o ambiente
          echo "Repositório: ${{ github.repository }}"
          echo "Owner: ${{ github.repository_owner }}"
          echo "Nome do repo: ${{ github.event.repository.name }}"
          echo "Versão: ${VERSION}"
          echo "Referência: ${{ github.ref }}"
          
          # Publicar cada arquivo ZIP como um pacote no GitHub Packages
          PUBLISH_SUCCESS=true
          for zipfile in terraform-provider-jumpcloud_*.zip; do
            echo "Publishing $zipfile to GitHub Packages"
            if curl -L \
              -X PUT \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$zipfile" \
              "https://api.github.com/repos/${{ github.repository }}/packages/generic/terraform-provider-jumpcloud/${VERSION}/$zipfile"; then
              echo "✅ Sucesso ao publicar $zipfile"
            else
              echo "❌ Erro ao publicar $zipfile"
              PUBLISH_SUCCESS=false
            fi
          done
          
          # Publicar checksums
          if [ -f SHA256SUMS ]; then
            echo "Publishing SHA256SUMS to GitHub Packages"
            if curl -L \
              -X PUT \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@SHA256SUMS" \
              "https://api.github.com/repos/${{ github.repository }}/packages/generic/terraform-provider-jumpcloud/${VERSION}/SHA256SUMS"; then
              echo "✅ Sucesso ao publicar SHA256SUMS"
            else
              echo "❌ Erro ao publicar SHA256SUMS"
              PUBLISH_SUCCESS=false
            fi
          else
            echo "⚠️ Warning: SHA256SUMS file not found!"
          fi
          
          # Verificar se todos os uploads foram bem-sucedidos
          if [ "$PUBLISH_SUCCESS" = true ]; then
            echo "🎉 Todos os pacotes foram publicados com sucesso!"
          else
            echo "⚠️ Alguns pacotes não foram publicados corretamente."
            exit 1
          fi
      
      - name: Create Documentation for Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Criando documentação para o pacote versão ${VERSION}..."
          
          # Definir a descrição da versão
          if [[ "$IS_BETA" == "true" ]]; then
            VERSION_DESC="Esta é uma versão beta (${VERSION}) do provider JumpCloud para Terraform."
          else
            VERSION_DESC="Esta é a versão ${VERSION} do provider JumpCloud para Terraform."
          fi
          
          cat << EOF > README-PACKAGE.md
          # JumpCloud Terraform Provider
          
          ${VERSION_DESC}
          
          ## Como usar este pacote
          
          Para usar este provider publicado no GitHub Packages, adicione o seguinte ao seu arquivo de configuração Terraform:
          
          ```hcl
          terraform {
            required_providers {
              jumpcloud = {
                source  = "github.com/${{ github.repository_owner }}/jumpcloud"
                version = "${VERSION}"
              }
            }
          }
          
          provider "jumpcloud" {
            # Configurações do provider
            api_key = "sua_api_key"
          }
          ```
          
          ## Configuração do Terraform para usar GitHub Packages como fonte
          
          Para que o Terraform use o GitHub Packages como fonte do provider, você precisa configurar o arquivo `~/.terraformrc` (Linux/Mac) ou `%APPDATA%\terraform.rc` (Windows):
          
          ```hcl
          provider_installation {
            network_mirror {
              url = "https://github.com/${{ github.repository }}/releases/download/v${VERSION}/"
              include = ["github.com/${{ github.repository_owner }}/jumpcloud"]
            }
            direct {
              exclude = ["github.com/${{ github.repository_owner }}/jumpcloud"]
            }
          }
          ```
          
          ## Arquivos disponíveis
          
          Os seguintes arquivos estão disponíveis:
          
          - terraform-provider-jumpcloud_${VERSION}_darwin_amd64.zip
          - terraform-provider-jumpcloud_${VERSION}_darwin_arm64.zip
          - terraform-provider-jumpcloud_${VERSION}_linux_amd64.zip
          - terraform-provider-jumpcloud_${VERSION}_linux_arm64.zip
          - terraform-provider-jumpcloud_${VERSION}_windows_amd64.zip
          - SHA256SUMS (checksums para verificação)
          
          ## Download direto
          
          Você pode baixar os binários diretamente usando:
          
          \`\`\`
          curl -LO https://github.com/${{ github.repository }}/packages/generic/terraform-provider-jumpcloud/${VERSION}/terraform-provider-jumpcloud_${VERSION}_[sua_plataforma].zip
          \`\`\`
          
          Substitua [sua_plataforma] pela plataforma desejada (ex: darwin_amd64, linux_amd64, etc).
          
          ## Instalação manual (alternativa)
          
          Para instalação manual, extraia o arquivo ZIP correspondente à sua plataforma na pasta de plugins do Terraform:
          
          - Linux/Mac: `~/.terraform.d/plugins/github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}/[os]_[arch]/`
          - Windows: `%APPDATA%\terraform.d\plugins\github.com\${{ github.repository_owner }}\jumpcloud\${VERSION}\[os]_[arch]\`
          
          Por exemplo, para Linux AMD64:
          ```bash
          mkdir -p ~/.terraform.d/plugins/github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}/linux_amd64/
          unzip terraform-provider-jumpcloud_${VERSION}_linux_amd64.zip -d ~/.terraform.d/plugins/github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}/linux_amd64/
          ```
          
          EOF
          
          # Confirmar que o arquivo foi criado
          echo "Arquivo README-PACKAGE.md criado:"
          cat README-PACKAGE.md
          
          # Publicar o README usando curl
          echo "Publicando documentação no GitHub Packages..."
          if curl -L \
            -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/octet-stream" \
            --data-binary "@README-PACKAGE.md" \
            "https://api.github.com/repos/${{ github.repository }}/packages/generic/terraform-provider-jumpcloud/${VERSION}/README.md"; then
            echo "✅ Documentação publicada com sucesso!"
          else
            echo "❌ Erro ao publicar a documentação"
            exit 1
          fi

  # Criar Release no GitHub (para qualquer versão, marcando beta quando apropriado)
  create-github-release:
    name: Create GitHub Release
    needs: [prepare-release, version, publish-packages]
    # Executa para tags, releases oficiais, merges para main/master/develop e workflow manual
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'workflow_dispatch') ||
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: Release v${{ needs.version.outputs.version }}
          files: |
            release/*.zip
            release/SHA256SUMS
          draft: false
          prerelease: ${{ needs.version.outputs.is_beta == 'true' }}
          generate_release_notes: true
      
      - name: Update CHANGELOG
        if: ${{ needs.version.outputs.is_beta != 'true' }}
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Gerar conteúdo para o changelog
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          echo "## v${VERSION} ($(date +%Y-%m-%d))" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          
          # Obter logs desde o último release não-beta
          LAST_STABLE_TAG=$(git tag -l --sort=-v:refname | grep -v -E '-(beta|alpha|rc|pr)' | head -n1)
          if [ -n "$LAST_STABLE_TAG" ]; then
            # Agrupar commits por tipo (feat, fix, etc)
            echo "### Features" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^feat(\([^)]+\))?:' | sed 's/^feat\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Bug Fixes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^fix(\([^)]+\))?:' | sed 's/^fix\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Documentation" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^docs(\([^)]+\))?:' | sed 's/^docs\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Other Changes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -v -E '^(feat|fix|docs)(\([^)]+\))?:' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
          else
            echo "* Initial release" >> $TEMP_CHANGELOG
            echo "" >> $TEMP_CHANGELOG
          fi
          
          # Adicionar o changelog anterior
          if [ -f CHANGELOG.md ]; then
            tail -n +3 CHANGELOG.md >> $TEMP_CHANGELOG
          fi
          
          # Substituir o changelog
          mv $TEMP_CHANGELOG CHANGELOG.md
          
          # Commit e push das mudanças se houver algo para committar
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to commit in CHANGELOG.md"
          else
            git commit -m "docs: atualizar CHANGELOG para v${VERSION}"
            git push
          fi

  # Build especial para a Terraform Registry (para todas as versões)
  registry-build:
    name: Registry Build
    # Executa para tags, releases oficiais, e merges para main/master/develop
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    needs: [create-github-release, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider for Registry Protocols
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building provider version ${VERSION} for Terraform Registry"
          
          # Criar diretório para os binários compilados
          mkdir -p dist
          
          # Compilar para os sistemas suportados
          GOOS=linux GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}
          GOOS=darwin GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_amd64
          GOOS=darwin GOARCH=arm64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_arm64
          GOOS=windows GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_windows_amd64.exe
      
      - name: Prepare Provider Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Criar diretório para o pacote
          mkdir -p terraform-provider-jumpcloud_${VERSION}
          
          # Copiar os binários compilados
          cp dist/* terraform-provider-jumpcloud_${VERSION}/
          
          # Adicionar arquivos necessários
          cp LICENSE terraform-provider-jumpcloud_${VERSION}/
          cp README.md terraform-provider-jumpcloud_${VERSION}/
          cp CHANGELOG.md terraform-provider-jumpcloud_${VERSION}/
          
          # Empacotar
          tar -czvf terraform-provider-jumpcloud_${VERSION}.tar.gz terraform-provider-jumpcloud_${VERSION}
      
      - name: Upload Provider Package
        uses: actions/upload-artifact@v4
        with:
          name: terraform-registry-package
          path: terraform-provider-jumpcloud_*.tar.gz
          if-no-files-found: error
          retention-days: 30
      
      - name: Registry Publishing Mockup
        run: |
          echo "Esta é uma etapa de mockup para publicação no Terraform Registry."
          echo "Em um ambiente real, você integraria com a API do Terraform Registry ou seguiria"
          echo "o processo adequado para publicação de providers externos." 