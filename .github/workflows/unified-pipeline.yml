name: Unified Build and Release Pipeline

on:
  push:
    branches: [ main, master, develop ]
    tags:
      - 'v*'
    paths-ignore:
      - 'README.md'
      - 'CHANGELOG.md'
      - 'docs/**'
      - '.gitignore'
  # Acionamento manual com parâmetros
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (without v prefix)'
        required: false
        default: ''
      is_beta:
        description: 'Is this a beta version'
        required: false
        default: false
        type: boolean
  # Release criada no GitHub
  release:
    types: [created]

# Permissões aplicadas a todo o workflow
permissions:
  contents: write
  packages: write

jobs:
  # Determinar a versão para o build
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      is_beta: ${{ steps.set-version.outputs.is_beta }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set Version
        id: set-version
        run: |
          # Determinar versão baseado no tipo de evento
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            # Versão fornecida manualmente
            VERSION="${{ github.event.inputs.version }}"
            IS_BETA="${{ github.event.inputs.is_beta }}"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Versão de uma tag
            VERSION=${GITHUB_REF#refs/tags/v}
            # Verificar se é beta baseado no nome da tag
            if [[ "$VERSION" == *-beta* || "$VERSION" == *-alpha* || "$VERSION" == *-rc* ]]; then
              IS_BETA="true"
            else
              IS_BETA="false"
            fi
          else
            # Determinação automática como fallback
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"
            
            # Remover 'v' do início
            LATEST_VERSION=${LATEST_TAG#v}
            
            # Dividir versão em partes: MAJOR.MINOR.PATCH
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            
            # Remover qualquer sufixo do PATCH (como -beta)
            PATCH=$(echo $PATCH | sed -E 's/([0-9]+).*/\1/')
            
            # Incrementar PATCH
            NEW_PATCH=$((PATCH + 1))
            
            # Determinar se é beta baseado na branch
            IS_BETA="false"
            if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              IS_BETA="true"
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}-beta"
            elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" ]]; then
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            else
              # Para outros casos
              VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi
          fi
          
          echo "Determined version: v${VERSION} (Beta: $IS_BETA)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "is_beta=${IS_BETA}" >> $GITHUB_OUTPUT

  # Executar testes antes do build
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: version
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Unit Tests
        run: make test-unit
  
  # Build para várias plataformas
  build:
    name: Build
    needs: [test, version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform:
          - {goos: linux, goarch: amd64, suffix: ''}
          - {goos: linux, goarch: arm64, suffix: ''}
          - {goos: darwin, goarch: amd64, suffix: ''}
          - {goos: darwin, goarch: arm64, suffix: ''}
          - {goos: windows, goarch: amd64, suffix: '.exe'}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider
        env:
          GOOS: ${{ matrix.platform.goos }}
          GOARCH: ${{ matrix.platform.goarch }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building for $GOOS/$GOARCH - version v${VERSION}"
          
          # Estrutura de diretórios compatível com Terraform
          # terraform-provider-jumpcloud_v${VERSION}_${OS}_${ARCH}/terraform-provider-jumpcloud_v${VERSION}
          PLUGIN_DIR=terraform-provider-jumpcloud_v${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          mkdir -p ${PLUGIN_DIR}
          
          # Compilar para a plataforma com nome correto
          go build -o ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Criar ZIP para o binário com a estrutura esperada pelo Terraform
          zip -j terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}/terraform-provider-jumpcloud_v${VERSION}${{ matrix.platform.suffix }}
          
          # Adicionar informações importantes dentro do ZIP
          echo "github.com/${{ github.repository_owner }}/jumpcloud/${VERSION}" > ${PLUGIN_DIR}/registry-url.txt
          zip -r terraform-provider-jumpcloud_${VERSION}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip ${PLUGIN_DIR}
      
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-provider-jumpcloud_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}
          path: terraform-provider-jumpcloud_${{ needs.version.outputs.version }}_${{ matrix.platform.goos }}_${{ matrix.platform.goarch }}.zip
          if-no-files-found: error
          retention-days: 7

  # Preparar para publicação
  prepare-release:
    name: Prepare Release
    needs: [build, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
      
      - name: Generate Checksums
        run: |
          # Mover todos os ZIPs para um único diretório
          mkdir -p release
          find . -name "terraform-provider-jumpcloud_*.zip" -exec cp {} release/ \;
          
          # Gerar checksums
          cd release
          sha256sum *.zip > SHA256SUMS
          cd ..
      
      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            release/*.zip
            release/SHA256SUMS
          if-no-files-found: error
          retention-days: 7

  # Criar Tag se não existir
  create-tag:
    name: Create Tag
    needs: [prepare-release, version]
    # Executa apenas se for push para branches main, master ou develop
    if: ${{ github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Create Tag if Not Exists
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Verificar se a tag já existe
          if ! git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Creating tag v${VERSION}"
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git tag -a "v${VERSION}" -m "Release v${VERSION}"
            git push origin "v${VERSION}"
            echo "Tag v${VERSION} created and pushed"
          else
            echo "Tag v${VERSION} already exists"
          fi

  # Publicar no GitHub Container Registry (GHCR)
  publish-packages:
    name: Publish to GitHub Container Registry
    needs: [prepare-release, version, create-tag]
    # Executa apenas se for push para branches main, master, develop, ou se for criada uma tag, ou manual dispatch
    if: |
      success() && (
        github.event_name == 'workflow_dispatch' || 
        startsWith(github.ref, 'refs/tags/') || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Prepare Provider for GHCR
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          cd release
          echo "Preparando provider para publicação no GHCR..."
          
          # Verificar conteúdo do diretório
          ls -la
          
          # Criar diretório de trabalho
          mkdir -p terraform-provider
          cp *.zip terraform-provider/
          cp SHA256SUMS terraform-provider/
          
          # Criar Dockerfile
          cat << EOF > terraform-provider/Dockerfile
          FROM alpine:3.17
          
          LABEL org.opencontainers.image.source=https://github.com/${{ github.repository }}
          LABEL org.opencontainers.image.description="JumpCloud Terraform Provider v${VERSION}"
          LABEL org.opencontainers.image.licenses=MIT
          
          WORKDIR /terraform-provider
          COPY *.zip /terraform-provider/
          COPY SHA256SUMS /terraform-provider/
          
          CMD ["sh", "-c", "echo 'This is a Terraform Provider container. Use with Terraform CLI.'"]
          EOF
          
          # Criar README
          cat << EOF > terraform-provider/README.md
          # JumpCloud Terraform Provider
          
          Esta imagem contém o provider JumpCloud para Terraform v${VERSION}.
          
          ## Como usar com Terraform
          
          Adicione a seguinte configuração ao seu arquivo Terraform:
          
          \`\`\`hcl
          terraform {
            required_providers {
              jumpcloud = {
                source  = "ghcr.io/${{ github.repository_owner }}/jumpcloud"
                version = "${VERSION}"
              }
            }
          }
          
          provider "jumpcloud" {
            api_key = "sua_api_key"
          }
          \`\`\`
          
          ## Configuração do Terraform para usar GHCR
          
          Adicione a seguinte configuração ao seu arquivo \`~/.terraformrc\` (Linux/Mac) ou \`%APPDATA%\\terraform.rc\` (Windows):
          
          \`\`\`hcl
          provider_installation {
            network_mirror {
              url = "https://ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud"
              include = ["ghcr.io/${{ github.repository_owner }}/jumpcloud"]
            }
            direct {
              exclude = ["ghcr.io/${{ github.repository_owner }}/jumpcloud"]
            }
          }
          \`\`\`
          
          ## Arquivos disponíveis
          
          Os seguintes arquivos estão incluídos neste container:
          
          - terraform-provider-jumpcloud_${VERSION}_darwin_amd64.zip
          - terraform-provider-jumpcloud_${VERSION}_darwin_arm64.zip
          - terraform-provider-jumpcloud_${VERSION}_linux_amd64.zip
          - terraform-provider-jumpcloud_${VERSION}_linux_arm64.zip
          - terraform-provider-jumpcloud_${VERSION}_windows_amd64.zip
          - SHA256SUMS
          EOF
      
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./release/terraform-provider
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${{ needs.version.outputs.version }}
            ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:latest
      
      - name: Create Documentation for GHCR Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
        run: |
          echo "Publicação no GHCR concluída com sucesso!"
          echo "Provider Terraform disponível em: ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${VERSION}"
          
          # Para versões beta, adicionar tag específica
          if [[ "$IS_BETA" == "true" ]]; then
            echo "Esta é uma versão beta."
            docker tag ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:v${VERSION} ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:beta
            docker push ghcr.io/${{ github.repository_owner }}/terraform-provider-jumpcloud:beta
            echo "Tag 'beta' também publicada."
          fi

  # Criar Release no GitHub (para qualquer versão, marcando beta quando apropriado)
  create-github-release:
    name: Create GitHub Release
    needs: [prepare-release, version, publish-packages]
    # Executa para tags, releases oficiais, merges para main/master/develop e workflow manual
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'workflow_dispatch') ||
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: release
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        env:
          VERSION: ${{ needs.version.outputs.version }}
          IS_BETA: ${{ needs.version.outputs.is_beta }}
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: Release v${{ needs.version.outputs.version }}
          files: |
            release/*.zip
            release/SHA256SUMS
          draft: false
          prerelease: ${{ needs.version.outputs.is_beta == 'true' }}
          generate_release_notes: true
      
      - name: Update CHANGELOG
        if: ${{ needs.version.outputs.is_beta != 'true' }}
        env:
          VERSION: ${{ needs.version.outputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Gerar conteúdo para o changelog
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          echo "## v${VERSION} ($(date +%Y-%m-%d))" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          
          # Obter logs desde o último release não-beta
          LAST_STABLE_TAG=$(git tag -l --sort=-v:refname | grep -v -E '-(beta|alpha|rc|pr)' | head -n1)
          if [ -n "$LAST_STABLE_TAG" ]; then
            # Agrupar commits por tipo (feat, fix, etc)
            echo "### Features" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^feat(\([^)]+\))?:' | sed 's/^feat\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Bug Fixes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^fix(\([^)]+\))?:' | sed 's/^fix\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Documentation" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -E '^docs(\([^)]+\))?:' | sed 's/^docs\([^)]*\): /* /' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
            
            echo "### Other Changes" >> $TEMP_CHANGELOG
            git log ${LAST_STABLE_TAG}..HEAD --pretty=format:"* %s" | grep -v -E '^(feat|fix|docs)(\([^)]+\))?:' >> $TEMP_CHANGELOG || true
            echo "" >> $TEMP_CHANGELOG
          else
            echo "* Initial release" >> $TEMP_CHANGELOG
            echo "" >> $TEMP_CHANGELOG
          fi
          
          # Adicionar o changelog anterior
          if [ -f CHANGELOG.md ]; then
            tail -n +3 CHANGELOG.md >> $TEMP_CHANGELOG
          fi
          
          # Substituir o changelog
          mv $TEMP_CHANGELOG CHANGELOG.md
          
          # Commit e push das mudanças se houver algo para committar
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to commit in CHANGELOG.md"
          else
            git commit -m "docs: atualizar CHANGELOG para v${VERSION}"
            git push
          fi

  # Build especial para a Terraform Registry (para todas as versões)
  registry-build:
    name: Registry Build
    # Executa para tags, releases oficiais, e merges para main/master/develop
    if: |
      success() && (
        startsWith(github.ref, 'refs/tags/') || 
        github.event_name == 'release' || 
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'))
      )
    needs: [create-github-release, version]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true
      
      - name: Build Provider for Registry Protocols
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Building provider version ${VERSION} for Terraform Registry"
          
          # Criar diretório para os binários compilados
          mkdir -p dist
          
          # Compilar para os sistemas suportados
          GOOS=linux GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}
          GOOS=darwin GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_amd64
          GOOS=darwin GOARCH=arm64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_darwin_arm64
          GOOS=windows GOARCH=amd64 go build -o dist/terraform-provider-jumpcloud_v${VERSION}_windows_amd64.exe
      
      - name: Prepare Provider Package
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Criar diretório para o pacote
          mkdir -p terraform-provider-jumpcloud_${VERSION}
          
          # Copiar os binários compilados
          cp dist/* terraform-provider-jumpcloud_${VERSION}/
          
          # Adicionar arquivos necessários
          cp LICENSE terraform-provider-jumpcloud_${VERSION}/
          cp README.md terraform-provider-jumpcloud_${VERSION}/
          cp CHANGELOG.md terraform-provider-jumpcloud_${VERSION}/
          
          # Empacotar
          tar -czvf terraform-provider-jumpcloud_${VERSION}.tar.gz terraform-provider-jumpcloud_${VERSION}
      
      - name: Upload Provider Package
        uses: actions/upload-artifact@v4
        with:
          name: terraform-registry-package
          path: terraform-provider-jumpcloud_*.tar.gz
          if-no-files-found: error
          retention-days: 30
      
      - name: Registry Publishing Mockup
        run: |
          echo "Esta é uma etapa de mockup para publicação no Terraform Registry."
          echo "Em um ambiente real, você integraria com a API do Terraform Registry ou seguiria"
          echo "o processo adequado para publicação de providers externos." 